import { useState, useEffect, useCallback } from 'react';
import toast from 'react-hot-toast';

export interface GeolocationState {
  lat: number | null;
  lng: number | null;
  accuracy: number | null;
  speed: number | null;
  heading: number | null;
  error: string | null;
  isLoading: boolean;
}

interface Options {
  enableHighAccuracy?: boolean;
  timeout?: number;
  maximumAge?: number;
  watchPosition?: boolean;
  onLocationUpdate?: (pos: GeolocationPosition) => void;
}

export function useGeolocation({
  enableHighAccuracy = true,
  timeout = 5000,
  maximumAge = 3000,
  watchPosition = true,
  onLocationUpdate,
}: Options = {}) {
  const [state, setState] = useState<GeolocationState>({
    lat: null,
    lng: null,
    accuracy: null,
    speed: null,
    heading: null,
    error: null,
    isLoading: false,
  });
  const [watchId, setWatchId] = useState<number | null>(null);

  const opts: PositionOptions = {
    enableHighAccuracy,
    timeout,
    maximumAge,
  };

  const updatePos = useCallback(
    (pos: GeolocationPosition) => {
      const { latitude, longitude, accuracy, speed, heading } = pos.coords;
      setState({
        lat: latitude,
        lng: longitude,
        accuracy,
        speed: speed != null ? speed * 3.6 : null,
        heading,
        error: null,
        isLoading: false,
      });
      onLocationUpdate?.(pos);
    },
    [onLocationUpdate]
  );

  const handleErr = useCallback((err: GeolocationPositionError) => {
    let msg = 'Unknown error';
    switch (err.code) {
      case err.PERMISSION_DENIED:
        msg = 'Permission denied';
        break;
      case err.POSITION_UNAVAILABLE:
        msg = 'Position unavailable';
        break;
      case err.TIMEOUT:
        msg = 'Timeout';
        break;
    }
    toast.error(msg);
    setState((s) => ({ ...s, error: msg, isLoading: false }));
  }, []);

  const getCurrentPosition = useCallback(() => {
    if (!navigator.geolocation) {
      handleErr({ code: 0, message: 'Geolocation unsupported' } as any);
      return;
    }
    setState((s) => ({ ...s, isLoading: true, error: null }));
    // prompt-timeout
    const permTimer = setTimeout(() => {
      if (state.isLoading) {
        toast.error('Please allow location access');
      }
    }, 3000);

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        clearTimeout(permTimer);
        updatePos(pos);
        if (watchPosition) startWatching();
      },
      (err) => {
        clearTimeout(permTimer);
        handleErr(err);
      },
      opts
    );
  }, [handleErr, opts, state.isLoading, updatePos, watchPosition]);

  const startWatching = useCallback(() => {
    if (!navigator.geolocation) return;
    if (watchId != null) navigator.geolocation.clearWatch(watchId);
    const id = navigator.geolocation.watchPosition(updatePos, handleErr, opts);
    setWatchId(id);
  }, [handleErr, opts, updatePos, watchId]);

  const stopWatching = useCallback(() => {
    if (watchId != null) navigator.geolocation.clearWatch(watchId);
    setWatchId(null);
    setState((s) => ({ ...s, isLoading: false }));
  }, [watchId]);

  const requestPermission = useCallback(async (): Promise<PermissionState> => {
    if (navigator.permissions) {
      try {
        const q = await navigator.permissions.query({ name: 'geolocation' });
        return q.state;
      } catch {}
    }
    // fallback
    return new Promise((res) =>
      navigator.geolocation.getCurrentPosition(
        () => res('granted'),
        (e) => (e.code === e.PERMISSION_DENIED ? res('denied') : res('prompt')),
        { timeout: 1000 }
      )
    );
  }, []);

  useEffect(() => () => {
    if (watchId != null) navigator.geolocation.clearWatch(watchId);
  }, [watchId]);

  return {
    ...state,
    getCurrentPosition,
    startWatching,
    stopWatching,
    requestPermission,
    isWatching: watchId != null,
  };
}